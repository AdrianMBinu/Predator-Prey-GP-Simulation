# -*- coding: utf-8 -*-
"""Final Copy of Final Assign2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1sBUSfoqfIcJTRiDCbT8ohgMe3B_F_mfm
"""

#install DEAP
!pip install deap

#import required packages

import copy
import random

import numpy
import re

from functools import partial

from deap import algorithms
from deap import base
from deap import creator
from deap import tools
from deap import gp

eatenFood=[]
food_copy=[]
simAntPos=[]
matrixRow=1
matrixCol=1

def progn(*args):
    for arg in args:
        arg()


def prog2(out1, out2):
    return partial(progn, out1, out2)


def prog3(out1, out2, out3):
    return partial(progn, out1, out2, out3)


def if_then_else(condition, out1, out2):
    out1() if condition() else out2()


class AntSimulator(object):
    direction = ["north", "east", "south", "west"]
    dir_row = [1, 0, -1, 0]
    dir_col = [0, 1, 0, -1]

    def __init__(self, max_moves):
        self.max_moves = max_moves
        self.moves = 0
        self.eaten = 0
        self.routine = None

    def _reset(self):
        self.row = self.row_start
        self.col = self.col_start
        self.dir = 1
        self.moves = 0
        self.eaten = 0
        self.matrix_exc = copy.deepcopy(self.matrix)
        self.food_copy = copy.deepcopy(self.food)
        self.eatenFood = []
        self.simAntPos = []

    @property
    def position(self):
        return (self.row, self.col, self.direction[self.dir])

    def turn_left(self):
        if self.moves < self.max_moves:
            self.updatePrey()
            self.moves += 1
            self.dir = (self.dir - 1) % 4

    def turn_right(self):
        if self.moves < self.max_moves:
            self.updatePrey()
            self.moves += 1
            self.dir = (self.dir + 1) % 4

    def move_forward(self):
        if self.moves < self.max_moves:
            self.updatePrey()
            self.moves += 1
            self.row = (self.row + self.dir_row[self.dir]) % self.matrix_row
            self.col = (self.col + self.dir_col[self.dir]) % self.matrix_col
            if self.matrix_exc[self.row][self.col] == "food":
                self.eaten += 1
                self.food_copy = [row for row in self.food_copy if row != [self.row,self.col]]
                self.eatenFood.append([self.row,self.col])
                self.matrix_exc[self.row][self.col] = "empty"
            self.simAntPos.append([self.row,self.col])

    def sense_food(self):
        ahead_row = (self.row + self.dir_row[self.dir]) % self.matrix_row
        ahead_col = (self.col + self.dir_col[self.dir]) % self.matrix_col
        return self.matrix_exc[ahead_row][ahead_col] == "food"

    def if_food_ahead(self, out1, out2):
        return partial(if_then_else, self.sense_food, out1, out2)

    def updatePrey(self):
      for row in self.food_copy:
        rand = random.randint(1, 4)
        if rand==1 and self.row!=row[1]+1 and row[1]+1<=self.matrix_row-1:
          #Move down
          self.matrix_exc[row[0]][row[1]]="empty"
          row[1]+=1
          self.matrix_exc[row[0]][row[1]]="food"
        elif rand==2 and self.row!=row[1]-1 and row[1]-1>=0:
          #Move up
          self.matrix_exc[row[0]][row[1]]="empty"
          row[1]-=1
          self.matrix_exc[row[0]][row[1]]="food"
        elif rand==3 and self.col!=row[0]+1 and row[0]+1<=self.matrix_col-1:
          #Move right
          self.matrix_exc[row[0]][row[1]]="empty"
          row[0]+=1
          self.matrix_exc[row[0]][row[1]]="food"
        elif rand==4 and self.col!=row[0]-1 and row[0]-1>=0:
          #Move left
          self.matrix_exc[row[0]][row[1]]="empty"
          row[0]-=1
          self.matrix_exc[row[0]][row[1]]="food"

        elif rand==1 and self.row!=row[1]+1:
          #Move down no barriers
          self.matrix_exc[row[0]][row[1]]="empty"
          row[1]=0
          self.matrix_exc[row[0]][row[1]]="food"
        elif rand==2 and self.row!=row[1]-1:
          #Move up no barriers
          self.matrix_exc[row[0]][row[1]]="empty"
          row[1]=self.matrix_row-1
          self.matrix_exc[row[0]][row[1]]="food"
        elif rand==3 and self.col!=row[0]+1:
          #Move right no barriers
          self.matrix_exc[row[0]][row[1]]="empty"
          row[0]=0
          self.matrix_exc[row[0]][row[1]]="food"
        elif rand==4 and self.col!=row[0]-1:
          #Move left no barriers
          self.matrix_exc[row[0]][row[1]]="empty"
          row[0]=self.matrix_col-1
          self.matrix_exc[row[0]][row[1]]="food"


    def run(self, routine):
        global eatenFood
        global food_copy
        global simAntPos
        global matrixRow
        global matrixCol

        self._reset()
        while self.moves < self.max_moves:
            routine()

        eatenFood = self.eatenFood
        food_copy=self.food_copy
        simAntPos=self.simAntPos
        matrixRow=self.matrix_row
        matrixCol=self.matrix_col

    def parse_matrix(self, matrix):
        self.matrix = list()
        self.food = []
        for i, line in enumerate(matrix):
            self.matrix.append(list())
            for j, col in enumerate(line):
                if col == ".":
                    self.matrix[-1].append("empty")
                elif col == "S":
                    self.matrix[-1].append("empty")
                    self.row_start = self.row = i
                    self.col_start = self.col = j
                    self.dir = 1
        self.matrix_row = len(self.matrix)
        self.matrix_col = len(self.matrix[0])

        self.generateFood()

        self.matrix_exc = copy.deepcopy(self.matrix)
        self.food_copy = copy.deepcopy(self.food)

    def generateFood(self):
      for i in range(60):############################################## number of foods
        randx = random.randint(0,self.matrix_col-1)
        randy = random.randint(0,self.matrix_row-1)
        self.matrix[randx][randy]="food"
        self.food.append([randx,randy])

ant = AntSimulator(600)############################################# number of max moves

pset = gp.PrimitiveSet("MAIN", 0)
pset.addPrimitive(ant.if_food_ahead, 2)
pset.addPrimitive(prog2, 2)
pset.addPrimitive(prog3, 3)
pset.addTerminal(ant.move_forward)
pset.addTerminal(ant.turn_left)
pset.addTerminal(ant.turn_right)

creator.create("FitnessMax", base.Fitness, weights=(1.0,))
creator.create("Individual", gp.PrimitiveTree, fitness=creator.FitnessMax)

toolbox = base.Toolbox()

# Attribute generator
toolbox.register("expr_init", gp.genFull, pset=pset, min_=1, max_=2)

# Structure initializers
toolbox.register("individual", tools.initIterate, creator.Individual, toolbox.expr_init)
toolbox.register("population", tools.initRepeat, list, toolbox.individual)


def evalArtificialAnt(individual):
    # Transform the tree expression to functional Python code
    routine = gp.compile(individual, pset)
    # Run the generated routine
    ant.run(routine)
    return ant.eaten,


toolbox.register("evaluate", evalArtificialAnt)
toolbox.register("select", tools.selTournament, tournsize=7)
toolbox.register("mate", gp.cxOnePoint)
toolbox.register("expr_mut", gp.genFull, min_=0, max_=2)
toolbox.register("mutate", gp.mutUniform, expr=toolbox.expr_mut, pset=pset)

#def main
# results
def moveDownSim(pos):
    pos[0] += 1
    return pos

def moveRightSim(pos):
    pos[1] += 1
    return pos
def moveUpSim(pos):
    pos[0] -= 1
    return pos

def moveLeftSim(pos):
    pos[1] -= 1
    return pos

def simulate_movement(steps):
    # Initialize the grid
    grid = [[0] * 10 for _ in range(10)]

    # Ant starts at position [0, 0]
    ant_position = [0, 0]

    # Mark the initial position
    grid[ant_position[0]][ant_position[1]] = 1

    # Simulate the ant's movement
    for step in steps:
        if step == "moveDown":
            ant_position = moveDownSim(ant_position)
        elif step == "moveRight":
            ant_position = moveRightSim(ant_position)
        elif step == "moveUp":
            ant_position = moveUpSim(ant_position)
        elif step == "moveLeft":
            ant_position = moveLeftSim(ant_position)

        # Mark the current position
        grid[ant_position[0]][ant_position[1]] = 1

    return grid

def parse_movement_string(movement_string):
    steps = []
    current_step = ""

    for char in movement_string:
        if char.isalpha():
            current_step += char
        elif char == "(":
            pass  # Start of a function call
        elif char == ")":
            if current_step and current_step.lower() != "pos" and current_step.lower() != "progn" and current_step.lower() != "prog2" and current_step.lower() != "prog3":
                steps.append(current_step.lower())  # Convert to lowercase and add to steps list
                current_step = ""

    return steps

def print_grid(grid):
    for row in grid:
        print(row)
def main(seed):
    random.seed(seed)

    with open("santafe_trail.txt") as trail_file:
      ant.parse_matrix(trail_file)

    pop = toolbox.population(n=100)
    hof = tools.HallOfFame(1)
    stats_fit = tools.Statistics(lambda ind: ind.fitness.values)
    stats_size = tools.Statistics(len)
    mstats = tools.MultiStatistics(fitness=stats_fit, size=stats_size)
    mstats.register("avg", numpy.mean)
    mstats.register("std", numpy.std)
    mstats.register("min", numpy.min)
    mstats.register("max", numpy.max)

    pop, log = algorithms.eaSimple(pop, toolbox, 0.7, 0.3, 50, stats=mstats,
                                   halloffame=hof, verbose=True)
    # print log
    fittest_individual = hof[0]
    fittest_fitness = fittest_individual.fitness.values[0]
    print("fittest: ", fittest_individual)
    print("fitness: ", fittest_fitness)

    evalArtificialAnt(fittest_individual)

    global eatenFood
    global food_copy
    global simAntPos
    global matrixRow
    global matrixCol
    print("position of eaten food")
    for row in eatenFood:
        print(row)

    print("position of surviving food")
    for row in food_copy:
        print(row)

    sim = [['_' for _ in range(matrixRow)] for _ in range(matrixCol)]


    for simAntPos in simAntPos:
        x,y=simAntPos
        sim[y][x]='o'

    for food in food_copy:
        x,y=food
        sim[y][x]='S'
    for eaten in eatenFood:
        x,y=eaten
        sim[y][x]='x'

    for row in sim:
        print(' '.join(row))
    print("Fitness:",len(eatenFood),"/",len(eatenFood)+len(food_copy))

    return pop, log, hof

num_runs=10 #change this variable to get as many runs as you want
for run in range(0,num_runs): # we are also iterating the seed here
  seed_value=run
  pop, log, hof = main(seed_value)